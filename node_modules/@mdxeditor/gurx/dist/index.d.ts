import { JSX as JSX_2 } from 'react/jsx-runtime';
import { default as React_2 } from 'react';

/**
 * Defines a new **stateless, valueless node** and returns a reference to it.
 * Once a realm instance publishes or subscribes to the node, an instance of that node it will be registered in the realm.
 * @param init - an optional function that will be called when the node is registered in a realm. Can be used to create subscriptions and define relationships to other nodes. Any referred nodes will be registered in the realm automatically.
 * @example
 * ```ts
 * const foo$ = Action((r) => {
 *   r.sub(foo$, () => console.log('foo action'))
 * })
 * const r = new Realm()
 * r.pub(foo$)
 * ```
 * @category Nodes
 * @remark An action is just a signal with `void` value. It can be used to trigger side effects.
 */
export declare function Action(init?: NodeInit<void>): NodeRef<void>;

/**
 * Defines a new **stateful node** and returns a reference to it.
 * Once a realm instance publishes or subscribes to the node, an instance of that node it will be registered in the realm.
 * @param value - the initial value of the node. Stateful nodes always have a value.
 * @param init - an optional function that will be called when the node is registered in a realm. Can be used to create subscriptions and define relationships to other nodes. Any referred nodes will be registered in the realm automatically.
 * @param distinct - if true, the node will only emit values that are different from the previous value. Optionally, a custom distinct function can be provided if the node values are non-primitive.
 * @example
 * ```ts
 * const foo$ = Cell('foo', true, (r) => {
 * r.sub(foo$, console.log)
 * })
 * const r = new Realm()
 * r.pub(foo$, 'bar') // the subscription will log 'bar'
 * ```
 * @remarks Unlike the RxJS `BehaviorSubject`, a stateful node does not immediately invoke its subscriptions when subscribed to. It only emits values when you publish something in it, either directly or through its relationships.
 * If you need to get the current value of a stateful node, use {@link Realm.getValue}.
 * @category Nodes
 */
export declare function Cell<T>(value: T, init?: (r: Realm) => void, distinct?: Distinct<T>): NodeRef<T>;

/**
 * A function which determines if two values are equal.
 * Implement custom comparators for distinct nodes that contain non-primitive values.
 * @param previous - The value that previously passed through the node. can be undefined if the node has not emitted a value yet.
 * @param current - The value currently passing.
 * @typeParam T - The type of values that the comparator compares.
 * @returns true if values should be considered equal.
 * @category Nodes
 */
export declare type Comparator<T> = (previous: T | undefined, current: T) => boolean;

/**
 * Debounces the output of a node with the specified delay.
 * @category Operators
 */
export declare function debounceTime<I>(delay: number): Operator<I, I>;

/**
 * The default comparator for distinct nodes - a function to determine if two values are equal. Works for primitive values.
 * @category Nodes
 */
export declare function defaultComparator<T>(current: T, next: T): boolean;

/**
 * Delays the output of a node with `queueMicrotask`.
 * @category Operators
 */
export declare function delayWithMicrotask<I>(): Operator<I, I>;

/**
 * A type for the distinct parameter to the {@link Cell} and {@link Signal} constructors.
 * @typeParam T - The type of values that the node emits.
 * @category Nodes
 */
export declare type Distinct<T> = boolean | Comparator<T>;

/**
 * Operator that filters the output of a node.
 * If the predicate returns false, the emission is canceled.
 * @category Operators
 */
export declare function filter<I, O = I>(predicate: (value: I) => boolean): Operator<I, O>;

/**
 * Handles a promise value through the specified callbacks.
 * @category Operators
 */
export declare function handlePromise<I, OutSuccess, OnLoad, OutError>(onLoad: () => OnLoad, onSuccess: (value: I) => OutSuccess, onError: (error: unknown) => OutError): Operator<I | Promise<I>, OutSuccess | OnLoad | OutError>;

/**
 * Maps a the passed value with a projection function.
 * @category Operators
 */
export declare function map<I, O>(mapFunction: (value: I) => O): Operator<I, O>;

/**
 * Operator that maps the output of a node to a fixed value.
 * @category Operators
 */
export declare function mapTo<I, O>(value: O): Operator<I, O>;

/**
 * A node initializer function.
 */
export declare type NodeInit<T> = (r: Realm, node$: NodeRef<T>) => void;

/**
 * A typed reference to a node.
 * @typeParam T - The type of values that the node emits.
 * @category Nodes
 */
export declare type NodeRef<T = unknown> = symbol & {
    valType: T;
};

/**
 * Shorter alias for {@link Operator}, to avoid extra long type signatures.
 * @category Operators
 */
export declare type O<In, Out> = Operator<In, Out>;

/**
 * Operator that captures the first emitted value of a node.
 * Useful if you want to execute a side effect only once.
 * @category Operators
 */
export declare function once<I>(): Operator<I, I>;

/**
 * description Buffers the stream of a node until the passed note emits.
 * @category Operators
 */
export declare function onNext<I, O>(bufNode: NodeRef<O>): Operator<I, [I, O]>;

/**
 * An operator that transforms a node into another node, used in the {@link Realm.pipe} method.
 * @typeParam In - The type of values that the incoming node will emit.
 * @typeParam Out - The type of values that the resulting node will emit.
 * @category Operators
 */
export declare type Operator<In, Out> = (source: NodeRef<In>, realm: Realm) => NodeRef<Out>;

export declare type ProjectionFunc<T extends unknown[] = unknown[]> = (done: (...values: unknown[]) => void) => (...args: T) => void;

/**
 * The realm is the actual "engine" that orchestrates any cells and signals that it touches. The realm also stores the state and the dependencies of the nodes that are referred through it.
 *
 */
export declare class Realm {
    private readonly subscriptions;
    private readonly singletonSubscriptions;
    private readonly graph;
    private readonly state;
    private readonly distinctNodes;
    private readonly executionMaps;
    private readonly definitionRegistry;
    /**
     * Creates a new realm.
     * @param initialValues - the initial cell values that will populate the realm.
     * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
     */
    constructor(initialValues?: Record<symbol, unknown>);
    /**
     * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
     * @returns a reference to the cell.
     * @param value - the initial value of the cell
     * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
     * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
     */
    cellInstance<T>(value: T, distinct?: Distinct<T>, node?: symbol): NodeRef<T>;
    /**
     * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
     * @returns a reference to the signal.
     * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
     * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
     */
    signalInstance<T>(distinct?: Distinct<T>, node?: symbol): NodeRef<T>;
    /**
     * Subscribes to the values published in the referred node.
     * @param node - the cell/signal to subscribe to.
     * @param subscription - the callback to execute when the node receives a new value.
     * @returns a function that, when called, will cancel the subscription.
     *
     * @example
     * ```ts
     * const signal$ = Signal<number>()
     * const r = new Realm()
     * const unsub = r.sub(signal$, console.log)
     * r.pub(signal$, 2)
     * unsub()
     * r.pub(signal$, 3)
     * ```
     */
    sub<T>(node: NodeRef<T>, subscription: Subscription<T>): UnsubscribeHandle;
    /**
     * Subscribes exclusively to values in the referred node.
     * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
     * Subscriptions created through `sub` are not affected.
     * @returns a function that, when called, will cancel the subscription.
     *
     * @example
     * ```ts
     * const signal$ = Signal<number>()
     * const r = new Realm()
     * // console.log will run only once.
     * r.singletonSub(signal$, console.log)
     * r.singletonSub(signal$, console.log)
     * r.singletonSub(signal$, console.log)
     * r.pub(signal$, 2)
     * ```
     */
    singletonSub<T>(node: NodeRef<T>, subscription: Subscription<T> | undefined): UnsubscribeHandle;
    /**
     * Clears all exclusive subscriptions.
     */
    resetSingletonSubs(): void;
    /**
     * Subscribes to multiple nodes at once. If any of the nodes emits a value, the subscription will be called with an array of the latest values from each node.
     * If the nodes change within a single execution cycle, the subscription will be called only once with the final node values.
     *
     * @example
     * ```ts
     * const foo$ = Cell('foo')
     * const bar$ = Cell('bar')
     *
     * const trigger$ = Signal<number>(true, (r) => {
     *   r.link(r.pipe(trigger$, map(i => `foo${i}`)), foo$)
     *   r.link(r.pipe(trigger$, map(i => `bar${i}`)), bar$)
     * })
     *
     * const r = new Realm()
     * r.subMultiple([foo$, bar$], ([foo, bar]) => console.log(foo, bar))
     * r.pub(trigger$, 2)
     * ```
     */
    subMultiple<T1>(nodes: [NodeRef<T1>], subscription: Subscription<[T1]>): UnsubscribeHandle;
    subMultiple<T1, T2>(nodes: [NodeRef<T1>, NodeRef<T2>], subscription: Subscription<[T1, T2]>): UnsubscribeHandle;
    subMultiple<T1, T2, T3>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>], subscription: Subscription<[T1, T2, T3]>): UnsubscribeHandle;
    subMultiple<T1, T2, T3, T4>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>], subscription: Subscription<[T1, T2, T3, T4]>): UnsubscribeHandle;
    subMultiple<T1, T2, T3, T4, T5>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>], subscription: Subscription<[T1, T2, T3, T4, T5]>): UnsubscribeHandle;
    subMultiple<T1, T2, T3, T4, T5, T6>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>], subscription: Subscription<[T1, T2, T3, T4, T5, T6]>): UnsubscribeHandle;
    subMultiple<T1, T2, T3, T4, T5, T6, T7>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>], subscription: Subscription<[T1, T2, T3, T4, T5, T6, T7]>): UnsubscribeHandle;
    subMultiple<T1, T2, T3, T4, T5, T6, T7, T8>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>], subscription: Subscription<[T1, T2, T3, T4, T5, T6, T7, T8]>): UnsubscribeHandle;
    subMultiple(nodes: Array<NodeRef<unknown>>, subscription: Subscription<any>): UnsubscribeHandle;
    /**
     * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
     * @param values - a record of node references and their values.
     *
     * @example
     * ```ts
     * const foo$ = Cell('foo')
     * const bar$ = Cell('bar')
     *
     * const r = new Realm()
     * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
     * ```
     */
    pubIn(values: Record<symbol, unknown>): void;
    /**
     * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
     * The nodes can be active (sources) or passive (pulls).
     */
    connect<T extends unknown[] = unknown[]>({ sources, pulls, map, sink, }: {
        /**
         * The source nodes that emit values to the sink node. The values will be passed as arguments to the map function.
         */
        sources: Array<NodeRef<unknown>>;
        /**
         * The nodes which values will be pulled. The values will be passed as arguments to the map function.
         */
        pulls?: Array<NodeRef<unknown>>;
        /**
         * The sink node that will receive the result of the map function.
         */
        sink: NodeRef<unknown>;
        /**
         * The projection function that will be called when any of the source nodes emits.
         */
        map: ProjectionFunc<T>;
    }): void;
    /**
     * Runs the subscrptions of this node.
     * @example
     * ```ts
     * const foo$ = Action((r) => {
     *  r.sub(foo$, console.log)
     * })
     *
     * const r = new Realm()
     * r.pub(foo$)
     */
    pub<T>(node: NodeRef<T>): void;
    /**
     * Publishes the specified value into a node.
     * @example
     * ```ts
     * const foo$ = Cell('foo')
     * const r = new Realm()
     * r.pub(foo$, 'bar')
     */
    pub<T>(node: NodeRef<T>, value: T): void;
    /**
     * Creates a new node that emits the values of the source node transformed through the specified operators.
     * @example
     * ```ts
     * const signal$ = Signal<number>(true, (r) => {
     *   const signalPlusOne$ = r.pipe(signal$, map(i => i + 1))
     *   r.sub(signalPlusOne$, console.log)
     * })
     * const r = new Realm()
     * r.pub(signal$, 1)
     */
    pipe<T>(s: NodeRef<T>): NodeRef<T>;
    pipe<T, O1>(s: NodeRef<T>, o1: O<T, O1>): NodeRef<O1>;
    pipe<T, O1, O2>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>]): NodeRef<O2>;
    pipe<T, O1, O2, O3>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>]): NodeRef<O3>;
    pipe<T, O1, O2, O3, O4>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>]): NodeRef<O4>;
    pipe<T, O1, O2, O3, O4, O5>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>]): NodeRef<O5>;
    pipe<T, O1, O2, O3, O4, O5, O6>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>]): NodeRef<O6>;
    pipe<T, O1, O2, O3, O4, O5, O6, O7>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>, O<O6, O7>]): NodeRef<O7>;
    pipe<T, O1, O2, O3, O4, O5, O6, O7, O8>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>, O<O6, O7>, O<O7, O8>]): NodeRef<O8>;
    pipe<T, O1, O2, O3, O4, O5, O6, O7, O8, O9>(s: NodeRef<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>, O<O6, O7>, O<O7, O8>, O<O8, O9>]): NodeRef<O9>;
    pipe<T>(source: NodeRef<T>, ...operators: Array<O<unknown, unknown>>): NodeRef<unknown>;
    /**
     * Works as a reverse pipe.
     * Constructs a function, that, when passed a certain node (sink), will create a node that will work as a publisher through the specified pipes into the sink.
     * @example
     * ```ts
     * const foo$ = Cell('foo')
     * const bar$ = Cell('bar')
     * const entry$ = Signal<number>(true, (r) => {
     *  const transform = r.transformer(map(x: number => `num${x}`))
     *  const transformFoo$ = transform(foo$)
     *  const transformBar$ = transform(bar$)
     *  r.link(entry$, transformFoo$)
     *  r.link(entry$, transformBar$)
     * })
     *
     * const r = new Realm()
     * r.pub(entry$, 1) // Both foo$ and bar$ now contain `num1`
     * ```
     */
    transformer<In>(...o: []): (s: NodeRef<In>) => NodeRef<In>;
    transformer<In, Out>(...o: [O<In, Out>]): (s: NodeRef<Out>) => NodeRef<In>;
    transformer<In, Out, O1>(...o: [O<In, O1>, O<O1, Out>]): (s: NodeRef<Out>) => NodeRef<In>;
    transformer<In, Out, O1, O2>(...o: [O<In, O1>, O<O1, O2>, O<O2, Out>]): (s: NodeRef<Out>) => NodeRef<In>;
    transformer<In, Out, O1, O2, O3>(...o: [O<In, O1>, O<O1, O2>, O<O2, O3>, O<O3, Out>]): (s: NodeRef<Out>) => NodeRef<In>;
    transformer<In, Out, O1, O2, O3, O4>(...o: [O<In, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, Out>]): (s: NodeRef<Out>) => NodeRef<In>;
    transformer<In, Out, O1, O2, O3, O4, O5>(...o: [O<In, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, Out>]): (s: NodeRef<Out>) => NodeRef<In>;
    transformer<In, Out>(...operators: Array<O<unknown, unknown>>): (s: NodeRef<Out>) => NodeRef<In>;
    /**
     * Links the output of a node to the input of another node.
     */
    link<T>(source: NodeRef<T>, sink: NodeRef<T>): void;
    /**
     * Combines the values from multiple nodes into a single node that emits an array of the latest values of the nodes.
     *
     * When one of the source nodes emits a value, the combined node emits an array of the latest values from each node.
     */
    combine<T1>(...nodes: [NodeRef<T1>]): NodeRef<T1>;
    combine<T1, T2>(...nodes: [NodeRef<T1>, NodeRef<T2>]): NodeRef<[T1, T2]>;
    combine<T1, T2, T3>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>]): NodeRef<[T1, T2, T3]>;
    combine<T1, T2, T3, T4>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>]): NodeRef<[T1, T2, T3, T4]>;
    combine<T1, T2, T3, T4, T5>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>]): NodeRef<[T1, T2, T3, T4, T5]>;
    combine<T1, T2, T3, T4, T5, T6>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>]): NodeRef<[T1, T2, T3, T4, T5, T6]>;
    combine<T1, T2, T3, T4, T5, T6, T7>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>, NodeRef<T13>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>, NodeRef<T13>, NodeRef<T14>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>, NodeRef<T13>, NodeRef<T14>, NodeRef<T15>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]>;
    combine<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>, NodeRef<T13>, NodeRef<T14>, NodeRef<T15>, NodeRef<T16>]): NodeRef<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]>;
    /**
     * Gets the current value of a node. The node must be stateful.
     * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
     * which means that if you call it within a computational cycle, you may not get the correct value.
     * @param node - the node instance.
     * @example
     * ```ts
     * const foo$ = Cell('foo')
     *
     * const r = new Realm()
     * r.getValue(foo$) // 'foo'
     * r.pub(foo$, 'bar')
     * //...
     * r.getValue(foo$) // 'bar'
     * ```
     */
    getValue<T>(node: NodeRef<T>): T;
    /**
     * Gets the current values of the specified nodes. Works just like {@link getValue}, but with an array of node references.
     */
    getValues<T1>(nodes: [NodeRef<T1>]): [T1];
    getValues<T1, T2>(nodes: [NodeRef<T1>, NodeRef<T2>]): [T1, T2];
    getValues<T1, T2, T3>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>]): [T1, T2, T3];
    getValues<T1, T2, T3, T4>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>]): [T1, T2, T3, T4];
    getValues<T1, T2, T3, T4, T5>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>]): [T1, T2, T3, T4, T5];
    getValues<T1, T2, T3, T4, T5, T6>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>]): [T1, T2, T3, T4, T5, T6];
    getValues<T1, T2, T3, T4, T5, T6, T7>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>]): [T1, T2, T3, T4, T5, T6, T7];
    getValues<T1, T2, T3, T4, T5, T6, T7, T8>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>]): [T1, T2, T3, T4, T5, T6, T7, T8];
    getValues<T1, T2, T3, T4, T5, T6, T7, T8, T9>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9];
    getValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10];
    getValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11];
    getValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12];
    getValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>, NodeRef<T13>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13];
    getValues<T>(nodes: Array<NodeRef<T>>): unknown[];
    /**
     * Explicitly includes the specified cell/signal reference in the realm.
     * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
     * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
     */
    register(node: NodeRef<unknown>): NodeRef<any>;
    /**
     * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
     * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
     * the map parameter gets called with the current value of the cell and the value published through the source.
     * @typeParam T - the type of the cell value.
     * @typeParam K - the type of the value published through the source.
     * @example
     * ```ts
     * const items$ = Cell<string[]([])
     * const addItem$ = Signal<string>(false, (r) => {
     *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
     * })
     * const r = new Realm()
     * r.pub(addItem$, 'foo')
     * r.pub(addItem$, 'bar')
     * r.getValue(items$) // ['foo', 'bar']
     * ```
     */
    changeWith<T, K>(cell: NodeRef<T>, source: NodeRef<K>, map: (cellValue: T, signalValue: K) => T): void;
    private calculateExecutionMap;
    private getExecutionMap;
    private combineOperators;
}

/**
 * @category React Components
 * The context that provides the realm to the built-in hooks.
 */
export declare const RealmContext: React_2.Context<Realm | null>;

/**
 * @category React Components
 */
export declare function RealmProvider({ children, initWith, updateWith, }: {
    /**
     * The children to render
     */
    children: React_2.ReactNode;
    /**
     * The initial values to set in the realm
     */
    initWith?: Record<string, unknown>;
    /**
     * The values to update in the realm on each render
     */
    updateWith?: Record<string, unknown>;
}): JSX_2.Element;

/**
 * Operator that runs with the latest and the current value of a node.
 * Works like the {@link https://rxjs.dev/api/operators/scan | RxJS scan operator}.
 * @category Operators
 */
export declare function scan<I, O>(accumulator: (current: O, value: I) => O, seed: O): Operator<I, O>;

/**
 * Defines a new **stateless node** and returns a reference to it.
 * Once a realm instance publishes or subscribes to the node, an instance of that node it will be registered in the realm.
 * @param init - an optional function that will be called when the node is registered in a realm. Can be used to create subscriptions and define relationships to other nodes. Any referred nodes will be registered in the realm automatically.
 * @param distinct - true by default. The node emits values that are different from the previous value. Optionally, a custom distinct function can be provided if the node values are non-primitive.
 * @example
 * ```ts
 * const foo$ = Signal<string>(true, (r) => {
 *   r.sub(foo$, console.log)
 * })
 * const r = new Realm()
 * r.pub(foo$, 'bar') // the subscription will log 'bar'
 * ```
 * @category Nodes
 */
export declare function Signal<T>(init?: NodeInit<T>, distinct?: Distinct<T>): NodeRef<T>;

/**
 * A function that is called when a node emits a value.
 * @typeParam T - The type of values that the node emits.
 */
export declare type Subscription<T> = (value: T) => unknown;

/**
 * Throttles the output of a node with the specified delay.
 * @category Operators
 */
export declare function throttleTime<I>(delay: number): Operator<I, I>;

/**
 * The resulting type of a subscription to a node. Can be used to cancel the subscription.
 */
export declare type UnsubscribeHandle = () => void;

/**
 * Returns a tuple of the current value of the cell and a publisher function (similar to useState).
 * The component will be re-rendered when the cell value changes.
 *
 * @remarks If you need just a publisher, use {@link usePublisher}.
 *
 * @param cell - The cell to use.
 * @returns A tuple of the current value of the cell and a publisher function.
 * @category Hooks
 */
export declare function useCell<T>(cell: NodeRef<T>): readonly [T, (value: T) => void];

/**
 * Gets the current value of the cell. The component is re-rendered when the cell value changes.
 *
 * @remark If you need the values of multiple nodes from the realm and those nodes might change in the same computiation, you can `useCellValues` to reduce re-renders.
 *
 * @returns The current value of the cell.
 * @typeParam T - the type of the value that the cell caries.
 * @param cell - The cell to use.
 *
 * @example
 * ```tsx
 * const cell$ = Cell(0)
 * //...
 * function MyComponent() {
 *   const cell = useCellValue(cell$)
 *   return <div>{cell}</div>
 * }
 * ```
 * @category Hooks
 */
export declare function useCellValue<T>(cell: NodeRef<T>): T;

/**
 * Retreives the values of the passed cells.
 * The component is re-rendered each time any of the referred cells changes its value.
 * @category Hooks
 *
 * @example
 * ```tsx
 * const foo$ = Cell('foo')
 * const bar$ = Cell('bar')
 * //...
 * function MyComponent() {
 *   const [foo, bar] = useCellValues(foo$, bar$)
 *   return <div>{foo} - {bar}</div>
 * }
 * ```
 */
export declare function useCellValues<T1>(...cells: [NodeRef<T1>]): [T1];

export declare function useCellValues<T1, T2>(...cells: [NodeRef<T1>, NodeRef<T2>]): [T1, T2];

export declare function useCellValues<T1, T2, T3>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>]): [T1, T2, T3];

export declare function useCellValues<T1, T2, T3, T4>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>]): [T1, T2, T3, T4];

export declare function useCellValues<T1, T2, T3, T4, T5>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>]): [T1, T2, T3, T4, T5];

export declare function useCellValues<T1, T2, T3, T4, T5, T6>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>]): [T1, T2, T3, T4, T5, T6];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>]): [T1, T2, T3, T4, T5, T6, T7];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7, T8>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>]): [T1, T2, T3, T4, T5, T6, T7, T8];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7, T8, T9>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12];

export declare function useCellValues<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(...cells: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>, NodeRef<T9>, NodeRef<T10>, NodeRef<T11>, NodeRef<T12>, NodeRef<T13>]): [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13];

/**
 * Returns a function that publishes its passed argument into the specified node.
 * @example
 * ```tsx
 * const signal$ = Signal<number>(true, (r) => {
 *  r.sub(signal$, (value) => console.log(`${value} was published in the signal`))
 * })
 * //...
 * function MyComponent() {
 *  const pub = usePublisher(signal$);
 *  return <button onClick={() => pub(2)}>Push a value into the signal</button>
 * }
 * ```
 * @category Hooks
 */
export declare function usePublisher<T>(node: NodeRef<T>): (value: T) => void;

/**
 * Returns a direct reference to the current realm. Use with caution.
 *
 * If possible, design your logic in a reactive manner, and use {@link useCellValue} and {@link usePublisher} to access the output of the realm.
 * @category Hooks
 */
export declare function useRealm(): Realm;

/**
 * Pulls the latest values from the passed nodes.
 * Note: The operator does not emit when the nodes emit. If you want to get that, use the `combine` function.
 * @category Operators
 */
export declare function withLatestFrom<I, T1>(...nodes: [NodeRef<T1>]): (source: NodeRef<I>) => NodeRef<[I, T1]>;

export declare function withLatestFrom<I, T1, T2>(...nodes: [NodeRef<T1>, NodeRef<T2>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2]>;

export declare function withLatestFrom<I, T1, T2, T3>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2, T3]>;

export declare function withLatestFrom<I, T1, T2, T3, T4>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2, T3, T4]>;

export declare function withLatestFrom<I, T1, T2, T3, T4, T5>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2, T3, T4, T5]>;

export declare function withLatestFrom<I, T1, T2, T3, T4, T5, T6>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2, T3, T4, T5, T6]>;

export declare function withLatestFrom<I, T1, T2, T3, T4, T5, T6, T7>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2, T3, T4, T5, T6, T7]>;

export declare function withLatestFrom<I, T1, T2, T3, T4, T5, T6, T7, T8>(...nodes: [NodeRef<T1>, NodeRef<T2>, NodeRef<T3>, NodeRef<T4>, NodeRef<T5>, NodeRef<T6>, NodeRef<T7>, NodeRef<T8>]): (source: NodeRef<I>) => NodeRef<[I, T1, T2, T3, T4, T5, T6, T7, T8]>;

export { }
