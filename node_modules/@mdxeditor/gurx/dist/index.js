var O = Object.defineProperty;
var N = (s, t, e) => t in s ? O(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var h = (s, t, e) => (N(s, typeof t != "symbol" ? t + "" : t, e), e);
import p from "react";
import { jsx as E } from "react/jsx-runtime";
class S {
  constructor(t = /* @__PURE__ */ new Map()) {
    this.map = t;
  }
  clone() {
    return new S(new Map(this.map));
  }
  increment(t) {
    const e = this.map.get(t) ?? 0;
    this.map.set(t, e + 1);
  }
  decrement(t, e) {
    let n = this.map.get(t);
    n !== void 0 && (n -= 1, this.map.set(t, n), n === 0 && e());
  }
}
class y {
  constructor() {
    h(this, "map", /* @__PURE__ */ new Map());
  }
  getOrCreate(t) {
    let e = this.map.get(t);
    return e === void 0 && (e = /* @__PURE__ */ new Set(), this.map.set(t, e)), e;
  }
  get(t) {
    return this.map.get(t);
  }
  use(t, e) {
    const n = this.get(t);
    n !== void 0 && e(n);
  }
  delete(t) {
    return this.map.delete(t);
  }
}
function d(s, t) {
  return t(s), s;
}
function k() {
}
function C(s, t) {
  return s === t;
}
const w = /* @__PURE__ */ new Map();
class V {
  /**
   * Creates a new realm.
   * @param initialValues - the initial cell values that will populate the realm.
   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.
   */
  constructor(t = {}) {
    h(this, "subscriptions", new y());
    h(this, "singletonSubscriptions", /* @__PURE__ */ new Map());
    h(this, "graph", new y());
    h(this, "state", /* @__PURE__ */ new Map());
    h(this, "distinctNodes", /* @__PURE__ */ new Map());
    h(this, "executionMaps", /* @__PURE__ */ new Map());
    h(this, "definitionRegistry", /* @__PURE__ */ new Set());
    for (const e of Object.getOwnPropertySymbols(t))
      this.state.set(e, t[e]);
  }
  /**
   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the cell.
   * @param value - the initial value of the cell
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  cellInstance(t, e = !0, n = Symbol()) {
    return this.state.has(n) || this.state.set(n, t), e !== !1 && !this.distinctNodes.has(n) && this.distinctNodes.set(n, e === !0 ? C : e), n;
  }
  /**
   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.
   * @returns a reference to the signal.
   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.
   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.
   */
  signalInstance(t = !0, e = Symbol()) {
    return t !== !1 && this.distinctNodes.set(e, t === !0 ? C : t), e;
  }
  /**
   * Subscribes to the values published in the referred node.
   * @param node - the cell/signal to subscribe to.
   * @param subscription - the callback to execute when the node receives a new value.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * const unsub = r.sub(signal$, console.log)
   * r.pub(signal$, 2)
   * unsub()
   * r.pub(signal$, 3)
   * ```
   */
  sub(t, e) {
    this.register(t);
    const n = this.subscriptions.getOrCreate(t);
    return n.add(e), () => n.delete(e);
  }
  /**
   * Subscribes exclusively to values in the referred node.
   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.
   * Subscriptions created through `sub` are not affected.
   * @returns a function that, when called, will cancel the subscription.
   *
   * @example
   * ```ts
   * const signal$ = Signal<number>()
   * const r = new Realm()
   * // console.log will run only once.
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.singletonSub(signal$, console.log)
   * r.pub(signal$, 2)
   * ```
   */
  singletonSub(t, e) {
    return this.register(t), e === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, e), () => this.singletonSubscriptions.delete(t);
  }
  /**
   * Clears all exclusive subscriptions.
   */
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  subMultiple(t, e) {
    const n = this.signalInstance();
    return this.connect({
      map: (i) => (...r) => {
        i(r);
      },
      sink: n,
      sources: t
    }), this.sub(n, e);
  }
  /**
   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.
   * @param values - a record of node references and their values.
   *
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   * const bar$ = Cell('bar')
   *
   * const r = new Realm()
   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})
   * ```
   */
  pubIn(t) {
    var l;
    const e = Reflect.ownKeys(t), n = this.getExecutionMap(e), i = n.refCount.clone(), r = n.participatingNodes.slice(), o = new Map(this.state), u = (f) => {
      this.graph.use(f, (c) => {
        for (const { sources: a, sink: b } of c)
          a.has(f) && i.decrement(b, () => {
            r.splice(r.indexOf(b), 1), u(b);
          });
      });
    };
    for (; ; ) {
      const f = r.shift();
      if (f === void 0)
        break;
      const c = f;
      let a = !1;
      const b = (g) => {
        const m = this.distinctNodes.get(c);
        if (m !== void 0 && m(o.get(c), g)) {
          a = !1;
          return;
        }
        a = !0, o.set(c, g), this.state.has(c) && this.state.set(c, g);
      };
      if (Object.prototype.hasOwnProperty.call(t, c) ? b(t[c]) : n.projections.use(c, (g) => {
        for (const m of g) {
          const M = [...Array.from(m.sources), ...Array.from(m.pulls)].map((R) => o.get(R));
          m.map(b)(...M);
        }
      }), a) {
        const g = o.get(c);
        this.subscriptions.use(c, (m) => {
          for (const M of m)
            M(g);
        }), (l = this.singletonSubscriptions.get(c)) == null || l(g);
      } else
        u(c);
    }
  }
  /**
   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.
   * The nodes can be active (sources) or passive (pulls).
   */
  connect({
    sources: t,
    pulls: e = [],
    map: n,
    sink: i
  }) {
    const r = {
      map: n,
      pulls: new Set(e),
      sink: this.register(i),
      sources: new Set(t)
    };
    for (const o of [...t, ...e])
      this.register(o), this.graph.getOrCreate(o).add(r);
    this.executionMaps.clear();
  }
  pub(t, e) {
    this.pubIn({ [t]: e });
  }
  pipe(t, ...e) {
    return this.combineOperators(...e)(t);
  }
  transformer(...t) {
    return (e) => d(this.signalInstance(), (n) => (this.link(this.pipe(n, ...t), e), n));
  }
  /**
   * Links the output of a node to the input of another node.
   */
  link(t, e) {
    this.connect({
      map: (n) => (i) => {
        n(i);
      },
      sink: e,
      sources: [t]
    });
  }
  // prettier-ignore
  combine(...t) {
    return d(this.signalInstance(), (e) => {
      this.connect({
        map: (n) => (...i) => {
          n(i);
        },
        sink: e,
        sources: t
      });
    });
  }
  /**
   * Gets the current value of a node. The node must be stateful.
   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,
   * which means that if you call it within a computational cycle, you may not get the correct value.
   * @param node - the node instance.
   * @example
   * ```ts
   * const foo$ = Cell('foo')
   *
   * const r = new Realm()
   * r.getValue(foo$) // 'foo'
   * r.pub(foo$, 'bar')
   * //...
   * r.getValue(foo$) // 'bar'
   * ```
   */
  getValue(t) {
    return this.register(t), this.state.get(t);
  }
  getValues(t) {
    return t.map((e) => this.getValue(e));
  }
  /**
   * Explicitly includes the specified cell/signal reference in the realm.
   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.
   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.
   */
  register(t) {
    const e = w.get(t);
    return e === void 0 || this.definitionRegistry.has(t) ? t : (this.definitionRegistry.add(t), d(
      e.type === "cell" ? this.cellInstance(e.initial, e.distinct, t) : this.signalInstance(e.distinct, t),
      (n) => {
        e.init(this, n);
      }
    ));
  }
  /**
   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).
   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.
   * the map parameter gets called with the current value of the cell and the value published through the source.
   * @typeParam T - the type of the cell value.
   * @typeParam K - the type of the value published through the source.
   * @example
   * ```ts
   * const items$ = Cell<string[]([])
   * const addItem$ = Signal<string>(false, (r) => {
   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])
   * })
   * const r = new Realm()
   * r.pub(addItem$, 'foo')
   * r.pub(addItem$, 'bar')
   * r.getValue(items$) // ['foo', 'bar']
   * ```
   */
  changeWith(t, e, n) {
    this.connect({
      sources: [e],
      pulls: [t],
      sink: t,
      map: (i) => (r, o) => {
        i(n(o, r));
      }
    });
  }
  calculateExecutionMap(t) {
    const e = [], n = /* @__PURE__ */ new Set(), i = new y(), r = new S(), o = new y(), u = (l, f = 0) => {
      r.increment(l), !n.has(l) && (this.register(l), i.use(l, (c) => {
        f = Math.max(...Array.from(c).map((a) => e.indexOf(a))) + 1;
      }), this.graph.use(l, (c) => {
        for (const a of c)
          a.sources.has(l) ? (o.getOrCreate(a.sink).add(a), u(a.sink, f)) : i.getOrCreate(a.sink).add(l);
      }), n.add(l), e.splice(f, 0, l));
    };
    return t.forEach(u), { participatingNodes: e, pendingPulls: i, projections: o, refCount: r };
  }
  getExecutionMap(t) {
    let e = t;
    if (t.length === 1) {
      e = t[0];
      const i = this.executionMaps.get(e);
      if (i !== void 0)
        return i;
    } else
      for (const [i, r] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === t.length && i.every((o) => t.includes(o)))
          return r;
    const n = this.calculateExecutionMap(t);
    return this.executionMaps.set(e, n), n;
  }
  combineOperators(...t) {
    return (e) => {
      for (const n of t)
        e = n(e, this);
      return e;
    };
  }
}
function K(s, t = k, e = !0) {
  return d(Symbol(), (n) => {
    w.set(n, { type: "cell", distinct: e, initial: s, init: t });
  });
}
function W(s = k, t = !1) {
  return d(Symbol(), (e) => {
    w.set(e, { type: "signal", distinct: t, init: s });
  });
}
function $(s = k) {
  return d(Symbol(), (t) => {
    w.set(t, { type: "signal", distinct: !1, init: s });
  });
}
const I = p.createContext(null);
function q({
  children: s,
  initWith: t,
  updateWith: e = {}
}) {
  const n = p.useMemo(() => new V(t), []);
  return p.useEffect(() => {
    n.pubIn(e);
  }, [e, n]), /* @__PURE__ */ E(I.Provider, { value: n, children: s });
}
function x() {
  const s = p.useContext(I);
  if (s === null)
    throw new Error("useRealm must be used within a RealmContextProvider");
  return s;
}
function j(s) {
  const t = x();
  t.register(s);
  const e = p.useCallback(
    (n) => t.sub(s, n),
    [t, s]
  );
  return p.useSyncExternalStore(e, () => t.getValue(s));
}
function D(...s) {
  const t = x(), e = p.useMemo(
    () => t.getValues(s),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  ), n = p.useRef(e), i = p.useCallback(
    (r) => {
      const o = (u) => {
        n.current = u, r();
      };
      return t.subMultiple(s, o);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t, ...s]
  );
  return p.useSyncExternalStore(i, () => n.current);
}
function v(s) {
  const t = x();
  return t.register(s), p.useCallback(
    (e) => {
      t.pub(s, e);
    },
    [t, s]
  );
}
function F(s) {
  return [j(s), v(s)];
}
function L(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        i(s(r));
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function z(...s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (...r) => {
        i(r);
      },
      pulls: s,
      sink: n,
      sources: [t]
    }), n;
  };
}
function B(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => () => {
        i(s);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function G(s) {
  return (t, e) => {
    const n = e.signalInstance();
    return e.connect({
      map: (i) => (r) => {
        s(r) && i(r);
      },
      sink: n,
      sources: [t]
    }), n;
  };
}
function H() {
  return (s, t) => {
    const e = t.signalInstance();
    let n = !1;
    return t.connect({
      map: (i) => (r) => {
        n || (n = !0, i(r));
      },
      sink: e,
      sources: [s]
    }), e;
  };
}
function J(s, t) {
  return (e, n) => {
    const i = n.signalInstance();
    return n.connect({
      map: (r) => (o) => {
        r(t = s(t, o));
      },
      sink: i,
      sources: [e]
    }), i;
  };
}
function Q(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (o) => {
      i = o, r === null && (r = setTimeout(() => {
        r = null, e.pub(n, i);
      }, s));
    }), n;
  };
}
function U(s) {
  return (t, e) => {
    const n = e.signalInstance();
    let i, r = null;
    return e.sub(t, (o) => {
      i = o, r !== null && clearTimeout(r), r = setTimeout(() => {
        e.pub(n, i);
      }, s);
    }), n;
  };
}
function X() {
  return (s, t) => {
    const e = t.signalInstance();
    return t.sub(s, (n) => {
      queueMicrotask(() => {
        t.pub(e, n);
      });
    }), e;
  };
}
function Y(s) {
  return (t, e) => {
    const n = e.signalInstance(), i = Symbol();
    let r = i;
    return e.connect({
      map: (o) => (u) => {
        r !== i && (o([r, u]), r = i);
      },
      sink: n,
      sources: [s]
    }), e.sub(t, (o) => r = o), n;
  };
}
function Z(s, t, e) {
  return (n, i) => {
    const r = i.signalInstance();
    return i.sub(n, (o) => {
      o !== null && typeof o == "object" && "then" in o ? (i.pub(r, s()), o.then((u) => {
        i.pub(r, t(u));
      }).catch((u) => {
        i.pub(r, e(u));
      })) : i.pub(r, t(o));
    }), r;
  };
}
export {
  $ as Action,
  K as Cell,
  V as Realm,
  I as RealmContext,
  q as RealmProvider,
  W as Signal,
  U as debounceTime,
  C as defaultComparator,
  X as delayWithMicrotask,
  G as filter,
  Z as handlePromise,
  L as map,
  B as mapTo,
  Y as onNext,
  H as once,
  J as scan,
  Q as throttleTime,
  F as useCell,
  j as useCellValue,
  D as useCellValues,
  v as usePublisher,
  x as useRealm,
  z as withLatestFrom
};
